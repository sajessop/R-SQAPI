
# The "r" way

# Load packages
```{r}
library(R6)
library(httr)
library(jsonlite)
library(magrittr)
```

# Create class SQAPI with property: host 
```{r}
SQAPI <- R6Class(
  "SQAPI",
  public = list(
    host = NULL,
    username = NULL,
    auth = NULL,
    initialize = function(host = NULL) {
      # Set default host
      if (is.null(host)){
        self$host <- "https://squidle.org"
      } else{
        self$host <- host
      }
      # Check if username and token are already stored in the session
      if (is.null(getOption("api_username")) ||
          is.null(getOption("api_token"))) {
        # If not, ask for them interactively
        self$username <- readline(prompt = "Enter your username: ")
        self$auth <- readline(prompt = "Enter your API token: ")
        
        # Store them in session for future use in this session
        options(api_username = self$username,
                api_token = self$auth)
      } else {
        # If they are already stored, use the saved values
        self$username <- getOption("api_username")
        self$auth <- getOption("api_token")
      }
    }
  )
)
```

# Function to construct host + endpoint
```{r}
base_url <- function(host, endpoint){
  url <- paste0(host,"/", endpoint)
  return(url)
}
```

# Function to append query filters
```{r}
query_filters <- function(base_url,
                          name,
                          op,
                          val,
                          page = NULL,
                          results_per_page = NULL
                          ) {
  filters <- list(
    list(name = name, op = op, val = val)
  )
  json_query <- jsonlite::toJSON(list(filters = filters), auto_unbox = TRUE)
  
  url <- paste0(base_url, "?q=", json_query)
  if (!is.null(page)) {
    url <- paste0(url, "&page=", page)
  }
  if (!is.null(results_per_page)) {
    url <- paste0(url, "&results_per_page=", results_per_page)
  }
  return(url)
}
```

# Function to make the VERB request
```{r}
request <- function(url, verb, user, token) {
  response <- httr::VERB(
    verb = verb,
    url = url,
    config = httr::authenticate(user = user, password = token)
  )
  
  cat("Response Status Code:", response$status_code)
  return(response)
}
```

```{r}
run_json_call <- function(full_url, api_token) {
  # Hit the API to get data
  res <- GET(URLencode(full_url), add_headers("X-auth-token" = api_token))
  json <- jsonlite::fromJSON(content(res, 'text', encoding = "UTF-8"), simplifyVector = TRUE, flatten = TRUE)

  # Poll request
  host <- "https://squidle.org"
  res2 <- NULL

  # Print status url
  print(paste0(host,json$status_url))

  # Initialize progress bar
  pb <- txtProgressBar(min = 0, max = 100, style = 3)
  
  while (TRUE) {
    # Poll the status URL to check progress
    res_raw <- GET(URLencode(paste0(host, json$status_url)), add_headers("X-auth-token" = api_token))
    res1 <- jsonlite::fromJSON(content(res_raw, 'text', encoding = "UTF-8"), simplifyVector = TRUE, flatten = TRUE)
    
    # Check if server indicates result is available
    if (res1$result_available || res1$status == "done") {
      res2 <- GET(URLencode(paste0(host, json$result_url)), add_headers("X-auth-token" = api_token))
      setTxtProgressBar(pb, 100)  # Set progress to 100% when done
      break
    } else if (res1$status == "error") {
      close(pb)  # Close progress bar on error
      stop("Error in processing the request.")
    }

    # Calculate overall progress bases on cumulative iterations
        stages <- res1$progress
    total_iterations <- sum(sapply(stages, function(stage) {
      if (!is.null(stage$iteration_count) && stage$iteration_count > 0) {
        stage$iteration_count
      } else {
        0
      }
    }))
    
    completed_iterations <- sum(sapply(stages, function(stage) {
      if (!is.null(stage$iteration_count) && stage$iteration_count > 0) {
        stage$iteration
      } else {
        0
      }
    }))
    
    # Calculate overall progress as a percentage
    if (total_iterations > 0) {
      overall_progress <- (completed_iterations / total_iterations) * 100
    } else {
      overall_progress <- 0
    }
    
    # Update the progress bar
    setTxtProgressBar(pb, overall_progress)
    
    Sys.sleep(1)  # Wait before polling again to avoid excessive requests
  }
  
  close(pb)  # Close progress bar
  
  # Flatten JSON results into a dataframe
  results_json <- jsonlite::fromJSON(content(res2, 'text', encoding = "UTF-8"), simplifyVector = TRUE, flatten = TRUE)
  
  return(results_json)
}
```


# Usage 
```{r}
# Initialize api to handle authentication (using default host)
api <- SQAPI$new()

# Construct base url (host + endpoint)
my_url <- base_url(api$host, endpoint = "api/media_collection") %>%
  query_filters(
    name = "media",
    op = "any",
    val = list(
      name = "deployment",
      op = "has",
      val = list(
        name = "campaign",
        op = "has",
        val = list(name = "key", op = "eq", val = "Batemans201011")
      )
    )
  )

# Send request using authentication from instance of SQAPI
r <- request(my_url, "GET", api$username, api$auth) 



```

```{r}
# parse JSON or handle errors
if (r$status_code == 200) {
  # Parse the response JSON content
  json_content <- httr::content(r, "text", encoding = "UTF-8")
  if (nchar(json_content) > 0) {
    my_list <- jsonlite::fromJSON(json_content, flatten = TRUE)
    my_df <- as.data.frame(my_list)
    
    # Print a preview of the data
    print("Succesful request")
    print(head(my_df))
  } else {
    print("No data")
  }
} else {
  # Print the error status and message
  print(paste("Didn't work. Status code:", r$status_code))
  print("Response content:")
  print(httr::content(r, "text", encoding = "UTF-8"))
}
```

