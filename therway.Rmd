
# The "r" way

# Load packages
```{r}
library(R6)
library(httr)
library(jsonlite)
```

# Create class SQAPI with property: host 
```{r}
SQAPI <- R6Class(
  "SQAPI",
  public = list(
    host = NULL,
    username = NULL,
    auth = NULL,
    initialize = function(host = NULL) {
      # Set default host
      if (is.null(host)){
        self$host <- "https://squidle.org"
      } else{
        self$host <- host
      }
      # Check if username and token are already stored in the session
      if (is.null(getOption("api_username")) ||
          is.null(getOption("api_token"))) {
        # If not, ask for them interactively
        self$username <- readline(prompt = "Enter your username: ")
        self$auth <- readline(prompt = "Enter your API token: ")
        
        # Store them in session for future use in this session
        options(api_username = self$username,
                api_token = self$auth)
      } else {
        # If they are already stored, use the saved values
        self$username <- getOption("api_username")
        self$auth <- getOption("api_token")
      }
    }
  )
)
```

# Function to construct host + endpoint
```{r}
base_url <- function(host, endpoint){
  url <- paste0(host,"/", endpoint)
  return(url)
}
```

# Function to append query filters
```{r}
## TO DO: add limit, offset, order_by, group_by, single params, AND hybrid attributes
query_filters <- function(base_url,
                          name,
                          op,
                          val,
                          page = NULL,
                          results_per_page = NULL
                          ) {
  filters <- list(
    list(name = name, op = op, val = val)
  )
  json_query <- jsonlite::toJSON(list(filters = filters), auto_unbox = TRUE)
  
  url <- paste0(base_url, "?q=", json_query)
  if (!is.null(page)) {
    url <- paste0(url, "&page=", page)
  }
  if (!is.null(results_per_page)) {
    url <- paste0(url, "&results_per_page=", results_per_page)
  }
  return(url)
}
```


# Function to make the VERB request with status polling and progress bar
```{r}
## TO DO: add support for POST and PATCH verbs eg (if (verb == "POST") allow sending of json)
## TO DO: tidy up polling for paginated results - currently only works for paginated endpoints if poll = FALSE
request <- function(url, verb, user, token, poll = TRUE) {
  response <- httr::VERB(
    verb = verb,
    url = url,
    config = httr::authenticate(user = user, password = token)
  )
  
  json <- jsonlite::fromJSON(
    content(response, 'text', encoding = "UTF-8"),
    simplifyVector = TRUE,
    flatten = TRUE
  )
    if (poll){
  # Poll
  results_response <- NULL
  
  # Define urls and print details
  host <- "https://squidle.org"
  status_url <- paste0(host, json$status_url)
  result_url <- paste0(host, json$result_url)
  print(json$message)
  print(paste0("Status url:", status_url))
  print(paste0("Results url:", result_url))

  # Initialize progress bar
  pbar <- txtProgressBar(min = 0, max = 100, style = 3)
  
    while (TRUE) {
    # Poll the status URL to check progress
    status_response <- httr::VERB(verb = verb, url = status_url, config = httr::authenticate(user = user, password = token))
    json_status_respones <- jsonlite::fromJSON(content(status_response, 'text', encoding = "UTF-8"), simplifyVector = TRUE, flatten = TRUE)
    
    # Check if server indicates result is available
    if (json_status_respones$result_available || json_status_respones$status == "done") {
      results_response <- httr::VERB(verb = verb, url = result_url, config = httr::authenticate(user = user, password = token))
      setTxtProgressBar(pbar, 100)  # Set progress to 100% when done
      break
    } else if (json_status_respones$status == "error") {
      close(pbar)  # Close progress bar on error
      stop("Error in processing the request.")
    }

    # Calculate overall progress bases on cumulative iterations
        stages <- json_status_respones$progress
    total_iterations <- sum(sapply(stages, function(stage) {
      if (!is.null(stage$iteration_count) && stage$iteration_count > 0) {
        stage$iteration_count
      } else {
        0
      }
    }))
    
    completed_iterations <- sum(sapply(stages, function(stage) {
      if (!is.null(stage$iteration_count) && stage$iteration_count > 0) {
        stage$iteration
      } else {
        0
      }
    }))
    
    # Calculate overall progress as a percentage
    if (total_iterations > 0) {
      overall_progress <- (completed_iterations / total_iterations) * 100
    } else {
      overall_progress <- 0
    }
    
    # Update the progress bar
    setTxtProgressBar(pbar, overall_progress)
    
    Sys.sleep(1)  # Wait before polling again to avoid excessive requests
  }
  
  close(pbar)  # Close progress bar
  
  # Flatten JSON results into a dataframe
  results_json <- jsonlite::fromJSON(content(results_response, 'text', encoding = "UTF-8"), simplifyVector = TRUE, flatten = TRUE)
  } else {
  results_json <- jsonlite::fromJSON(content(response, 'text', encoding = "UTF-8"), simplifyVector = TRUE, flatten = TRUE)
  }
  
 cat("Response Status Code:", response$status_code, "\n")
  return(results_json)
}
```


# Usage 
```{r}
# Initialize api to handle authentication (using default host)
api <- SQAPI$new()

# Construct base url (host + endpoint)
## Simple query example
my_url <- base_url(api$host, endpoint = "api/annotation_set") %>%
  query_filters(
    name = "id",
    op = "eq",
    val = "2194")

## Nested query
my_url <- base_url(api$host, endpoint = "api/media_collection") %>%
  query_filters(
    name = "media",
    op = "any",
    val = list(
      name = "deployment",
      op = "has",
      val = list(
        name = "campaign",
        op = "has",
        val = list(name = "key", op = "eq", val = "Batemans201011")
      )
    )
  )

# Send request using authentication from instance of SQAPI
## Annotation endpoint example
### TO DO: fails if poll = TRUE for paginated endpoints (Something to do with json formatting)
r <- request(my_url, "GET", api$username, api$auth, poll = FALSE)

## Export endpoint example with polling and status bar
r <- request("https://squidle.org/api/annotation_set/2194/export", "GET", api$username, api$auth) 

```

```{r}
# parse JSON or handle errors
if (r$status_code == 200) {
  # Parse the response JSON content
  json_content <- httr::content(r, "text", encoding = "UTF-8")
  if (nchar(json_content) > 0) {
    my_list <- jsonlite::fromJSON(json_content, flatten = TRUE)
    my_df <- as.data.frame(my_list)
    
    # Print a preview of the data
    print("Succesful request")
    print(head(my_df))
  } else {
    print("No data")
  }
} else {
  # Print the error status and message
  print(paste("Didn't work. Status code:", r$status_code))
  print("Response content:")
  print(httr::content(r, "text", encoding = "UTF-8"))
}
```

